(*
  FB_TemperatureManager_v3
  - Типы: BOOL / UDINT / REAL (совместимо с owenLogic).
  - Интерфейс с FB_PasteurManager: Pasteur_HeatEnable (разрешение нагрева)
    и HeatTargetTemp (уставка, °C).
  - В зависимости от PAR_UsePID:
      * TRUE  → ПИД по (SP_TempTarget, PV_TempProduct), выход 0..100 %, далее ШИМ + каскад групп.
      * FALSE → Гистерезис по PV/SP (двоичный: 0/100 %), далее тот же ШИМ + каскад групп.
  - ШИМ тайм-пропорциональный с периодом PAR_PWM_Period_s (SSR: 1..2 c; контактор: 10..30 c).
  - Фильтрация температур: IIR 1-го порядка (alpha из PAR_FilterAlpha_x1000: 0..1000 → 0..1).
  - Защита по ΔT рубашка–продукт: если превышена SmoothDiffGuard, мощность ограничивается.
  - При работе в гистерезисе выводит Hyst_HeatRequest для HMI (состояние текущего запроса нагрева).
*)

FUNCTION_BLOCK FB_TemperatureManager_v3

VAR_INPUT
    // Сырые (уже преобразованные в MAIN) температуры, °C:
    PV_TempProduct_Raw        : REAL;       // продукт
    PV_TempJacket_Raw         : REAL;       // рубашка

    // Режим работы:
    PAR_UsePID                : BOOL;       // TRUE: ПИД, FALSE: гистерезис

    // Управление от пастеризатора:
    Pasteur_HeatEnable        : BOOL;       // разрешение нагрева от FB_PasteurManager
    SP_TempTarget             : REAL;       // целевая T (°C) для ПИД/гистерезиса

    // Время/ШИМ:
    Seconds_UD                : UDINT;      // секундный тик из MAIN
    PAR_PWM_Period_s          : UDINT;      // период ШИМ, с (SSR 1..2; контактор 10..30)

    // Каскад групп (пороги включения в %, 0..100):
    PAR_G2_StartPct           : REAL;       // дефолт 60 (%)
    PAR_G3_StartPct           : REAL;       // дефолт 85 (%)

    // Разрешение групп (из MAIN):
    PAR_HeaterGroup2Enabled   : BOOL;       // TRUE = разрешить DO_Heater2
    PAR_HeaterGroup3Enabled   : BOOL;       // TRUE = разрешить DO_Heater3

    // Фильтр температур:
    PAR_FilterAlpha_x1000     : UDINT;      // 0..1000 → 0.000..1.000 (0=без фильтра)

    // ===== Параметры гистерезиса =====
    HYST_OnBelow              : REAL;       // включать, если PV ≤ SP − OnBelow (°C)
    HYST_OffEarly             : REAL;       // выключать, если PV ≥ SP − OffEarly (°C)
    HYST_MinOn_s              : UDINT;      // минимальное «вкл», c
    HYST_MinOff_s             : UDINT;      // минимальное «выкл», c
    HYST_Equilize_s           : UDINT;      // пауза уравновешивания после выкл, c
    SmoothDiffGuard           : REAL;       // макс. допустимая ΔT рубашка–продукт, °C
    PAR_MaxDutyPct_JacketGuard: REAL;       // макс. % при превышении ΔT (например 20)

    // ===== Параметры ПИД =====
    PAR_PID_Kp                : REAL;       // безразмерный
    PAR_PID_Ti                : REAL;       // сек (0 = без интеграла)
    PAR_PID_Td                : REAL;       // сек (0 = без дифференциала)
END_VAR

VAR_OUTPUT
    // Команды на силовую часть:
    Cmd_HeaterGroup1          : BOOL;       // группа 1 (DO6)
    Cmd_HeaterGroup2          : BOOL;       // группа 2 (DO7)
    Cmd_HeaterGroup3          : BOOL;       // группа 3 (DO8)
    AO_HeaterPower            : REAL;       // 0..100 %, аналоговая команда (для группы 1 / индикации)

    // Отфильтрованные температуры:
    PV_TempProduct            : REAL;       // °C
    PV_TempJacket             : REAL;       // °C

    // Диагностика/индикация:
    DutyPct                   : REAL;       // итоговая мощность после ограничений, %
    Hyst_HeatRequest          : BOOL;       // TRUE, когда гистерезис требует нагрев (PAR_UsePID = FALSE)
END_VAR

VAR
    // Фильтр
    filterAlpha               : REAL;       // 0..1

    // Внутреннее состояние гистерезиса
    hystState                 : BOOL;       // текущий «вкл/выкл»
    lastOnSec                 : UDINT;
    lastOffSec                : UDINT;
    equilizeUntil             : UDINT;

    // Внутреннее ПИД
    pidIntegral               : REAL;
    prevProductTemp           : REAL;
    lastSecondTick            : UDINT;

    // Общие
    dutyPctInternal           : REAL;       // 0..100 % — итоговая мощность для ШИМ
    pwmPeriod_s               : UDINT;
    pwmPeriodR                : REAL;
    pwmPhaseR                 : REAL;

    // Локальные рабочие
    dtSeconds                 : REAL;
    controlError              : REAL;
    proportionalTerm          : REAL;
    integralTerm              : REAL;
    derivativeTerm            : REAL;

    g2Threshold               : REAL;
    g3Threshold               : REAL;

    jacketGuardActive         : BOOL;
END_VAR

// ===== ФИЛЬТР АЛЬФА =====
IF PAR_FilterAlpha_x1000 >= 1000 THEN
    filterAlpha := 1.0;
ELSE
    filterAlpha := UDINT_TO_REAL(PAR_FilterAlpha_x1000) / 1000.0;
    IF filterAlpha < 0.0 THEN filterAlpha := 0.0; END_IF;
END_IF;

// ===== ИНИЦИАЛИЗАЦИЯ ПРИ ИЗМЕНЕНИИ ВРЕМЕНИ =====
IF lastSecondTick = 0 THEN
    lastSecondTick := Seconds_UD;
    PV_TempProduct := PV_TempProduct_Raw;
    PV_TempJacket  := PV_TempJacket_Raw;
    lastOffSec     := Seconds_UD;
END_IF;

// ===== ФИЛЬТРАЦИЯ ТЕМПЕРАТУР =====
IF filterAlpha <= 0.0 THEN
    PV_TempProduct := PV_TempProduct_Raw;
    PV_TempJacket  := PV_TempJacket_Raw;
ELSE
    PV_TempProduct := PV_TempProduct + filterAlpha * (PV_TempProduct_Raw - PV_TempProduct);
    PV_TempJacket  := PV_TempJacket  + filterAlpha * (PV_TempJacket_Raw  - PV_TempJacket);
END_IF;

// ===== ТАЙМЕРЫ / DT =====
IF Seconds_UD >= lastSecondTick THEN
    dtSeconds := UDINT_TO_REAL(Seconds_UD - lastSecondTick);
ELSE
    dtSeconds := 1.0; // на всякий случай
END_IF;
IF dtSeconds <= 0.0 THEN dtSeconds := 1.0; END_IF;
lastSecondTick := Seconds_UD;

// ===== НОРМАЛИЗАЦИЯ ПАРАМЕТРОВ =====
pwmPeriod_s := PAR_PWM_Period_s; IF pwmPeriod_s = 0 THEN pwmPeriod_s := 1; END_IF;
pwmPeriodR  := UDINT_TO_REAL(pwmPeriod_s);

g2Threshold := PAR_G2_StartPct; IF g2Threshold < 0.0 THEN g2Threshold := 0.0; END_IF; IF g2Threshold > 100.0 THEN g2Threshold := 100.0; END_IF;
g3Threshold := PAR_G3_StartPct; IF g3Threshold < 0.0 THEN g3Threshold := 0.0; END_IF; IF g3Threshold > 100.0 THEN g3Threshold := 100.0; END_IF;

// ===== ОГРАНИЧЕНИЕ ПО ΔT РУБАШКА–ПРОДУКТ =====
jacketGuardActive := (PV_TempJacket > (PV_TempProduct + SmoothDiffGuard));

Hyst_HeatRequest := FALSE;

// ===== ОСНОВНОЙ ВЫБОР ТРАКТА (PID / HYST) =====
IF (NOT Pasteur_HeatEnable) THEN
    // Нагрев запрещён окном стадии — всё в ноль
    dutyPctInternal := 0.0;
    hystState := FALSE;

    // анти-виндап: подпритормаживаем интегратор
    IF PAR_PID_Ti > 0.0 THEN
        pidIntegral := pidIntegral * 0.98;
    ELSE
        pidIntegral := 0.0;
    END_IF;

ELSE
    IF PAR_UsePID THEN
        // ===== ПИД-тракт =====
        controlError := SP_TempTarget - PV_TempProduct;

        // P
        proportionalTerm := PAR_PID_Kp * controlError;

        // I (с анти-виндапом)
        IF PAR_PID_Ti > 0.0 THEN
            pidIntegral := pidIntegral + (controlError / PAR_PID_Ti) * dtSeconds;
            IF pidIntegral > 100.0 THEN pidIntegral := 100.0; END_IF;
            IF pidIntegral < -100.0 THEN pidIntegral := -100.0; END_IF;
            integralTerm := pidIntegral;
        ELSE
            integralTerm := 0.0;
        END_IF;

        // D по PV (чтобы не дёргалось на скачке SP)
        IF PAR_PID_Td > 0.0 THEN
            derivativeTerm := - PAR_PID_Td * (PV_TempProduct - prevProductTemp) / dtSeconds;
        ELSE
            derivativeTerm := 0.0;
        END_IF;
        prevProductTemp := PV_TempProduct;

        // Сумма и кламп 0..100 %
        dutyPctInternal := proportionalTerm + integralTerm + derivativeTerm;

    ELSE
        // ===== Гистерезис-тракт =====
        // ВКЛ:  PV ≤ SP − OnBelow   и выдержан MinOff   и не превышена ΔT рубашки
        // ВЫКЛ: PV ≥ SP − OffEarly  и выдержан MinOn
        // Пауза «уравновешивания» после выключения: HYST_Equilize_s

        IF Seconds_UD < equilizeUntil THEN
            hystState := FALSE;
        ELSE
            IF NOT hystState THEN
                IF (PV_TempProduct <= (SP_TempTarget - HYST_OnBelow)) AND
                   ((Seconds_UD - lastOffSec) >= HYST_MinOff_s) AND
                   (NOT jacketGuardActive) THEN
                    hystState := TRUE;
                    lastOnSec := Seconds_UD;
                END_IF;
            ELSE
                IF (PV_TempProduct >= (SP_TempTarget - HYST_OffEarly)) AND
                   ((Seconds_UD - lastOnSec) >= HYST_MinOn_s) THEN
                    hystState := FALSE;
                    lastOffSec := Seconds_UD;
                    equilizeUntil := Seconds_UD + HYST_Equilize_s;
                END_IF;
            END_IF;
        END_IF;

        IF hystState THEN
            dutyPctInternal := 100.0;
        ELSE
            dutyPctInternal := 0.0;
        END_IF;

        Hyst_HeatRequest := hystState;

        pidIntegral := 0.0;
        prevProductTemp := PV_TempProduct;
    END_IF;
END_IF;

// ===== ОГРАНИЧЕНИЕ И КОРРЕКЦИЯ =====
IF dutyPctInternal < 0.0 THEN dutyPctInternal := 0.0; END_IF;
IF dutyPctInternal > 100.0 THEN dutyPctInternal := 100.0; END_IF;

IF jacketGuardActive THEN
    IF PAR_MaxDutyPct_JacketGuard < dutyPctInternal THEN
        dutyPctInternal := PAR_MaxDutyPct_JacketGuard;
    END_IF;
END_IF;

DutyPct := dutyPctInternal;
AO_HeaterPower := DutyPct;

// ===== ШИМ И КАСКАД ГРУПП =====
pwmPhaseR := UDINT_TO_REAL(Seconds_UD MOD pwmPeriod_s);
Cmd_HeaterGroup1 := (DutyPct > 0.0) AND (pwmPhaseR < (pwmPeriodR * (DutyPct / 100.0)));

IF (DutyPct >= g2Threshold) AND PAR_HeaterGroup2Enabled THEN
    Cmd_HeaterGroup2 := Cmd_HeaterGroup1;
ELSE
    Cmd_HeaterGroup2 := FALSE;
END_IF;

IF (DutyPct >= g3Threshold) AND PAR_HeaterGroup3Enabled THEN
    Cmd_HeaterGroup3 := Cmd_HeaterGroup1;
ELSE
    Cmd_HeaterGroup3 := FALSE;
END_IF;

END_FUNCTION_BLOCK
